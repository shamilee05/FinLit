# -*- coding: utf-8 -*-
"""finlit_fuzzy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1emoiTeR2MyPf2uoezjtEFH8nxNf8jPZr
"""

# pip install -U scikit-fuzzy
import sys

# import subprocess

# def install(package):
#     subprocess.check_call([sys.executable, "-m", "pip", "install", package])
    
# install("scikit-fuzzy")

import numpy as np
import skfuzzy as fuzz
from skfuzzy import control as ctrl

# New Antecedent/Consequent objects hold universe variables and membership functions
previous = ctrl.Antecedent(np.arange(0, 5, 1), 'previous')  # 4 questions so 0-5, step can be 1
current_level = ctrl.Antecedent(np.arange(0, 3, 1), 'current_level')  # 3 levels so 0->beginner, 1->intermediate, 2->expert
# time = ctrl.Antecedent(np.arange(0, 11, 1), 'time')
next_level = ctrl.Consequent(np.arange(0, 3, 1), 'next_level')  # 3 levels so 0->beginner, 1->intermediate, 2->expert
var1 = 0

# Auto-membership function population is possible with .automf(3, 5, or 7)
# current_level.automf(3)
# next_level.automf(3)

# Custom membership functions can be built interactively with a familiar,
# Pythonic API
# tip['low'] = fuzz.trimf(tip.universe, [0, 0, 13])
# tip['medium'] = fuzz.trimf(tip.universe, [0, 13, 25])
# tip['high'] = fuzz.trimf(tip.universe, [13, 25, 25])

# Custom membership function for the previous questions, can do auto for the rest
previous['poor'] = fuzz.trimf(previous.universe, [0, 0, 2])
previous['average'] = fuzz.trimf(previous.universe, [0, 2, 4])
previous['good'] = fuzz.trimf(previous.universe, [2, 4, 4])

names = ['beginner', 'intermediate', 'expert']
current_level.automf(names=names)
next_level.automf(names=names)

# current_level['beginner'] = fuzz.genmf('singletonmf', 0)
# current_level['intermediate'] = fuzz.genmf('singletonmf', 1)
# current_level['expert'] = fuzz.genmf('singletonmf', 2)

# next_level['beginner'] = fuzz.genmf('singletonmf', 0)
# next_level['intermediate'] = fuzz.genmf('singletonmf', 1)
# next_level['expert'] = fuzz.genmf('singletonmf', 2)

"""
To help understand what the membership looks like, use the ``view`` methods.
"""

# You can see how these look with .view()
previous.view()
"""
# .. image:: PLOT2RST.current_figure
"""
current_level.view()
"""
# .. image:: PLOT2RST.current_figure
"""
next_level.view()
"""
# .. image:: PLOT2RST.current_figure


Fuzzy rules
-----------

Now, to make these triangles useful, we define the *fuzzy relationship*
between input and output variables. For the purposes of our example, consider
three simple rules:

1. If the previous score is good OR the current user level is expert, then the next level will be expert
2. If the previous score is average, then the next level will be intermediate
3. If the previous score is poor OR the current user level is beginner, then the next level will be beginner.

Most people would agree on these rules, but the rules are fuzzy. Mapping the
imprecise rules into a defined, actionable tip is a challenge. This is the
kind of task at which fuzzy logic excels.
"""

rule1 = ctrl.Rule(previous['good'] & current_level['expert'], next_level['expert'])
rule2 = ctrl.Rule(previous['average'], next_level['intermediate'])
rule3 = ctrl.Rule(previous['poor'] & current_level['beginner'], next_level['beginner'])
rule4 = ctrl.Rule(previous['poor'] & current_level['intermediate'], next_level['beginner'])
rule5 = ctrl.Rule(previous['poor'] & current_level['expert'], next_level['intermediate'])
rule6 = ctrl.Rule(previous['good'] & current_level['intermediate'], next_level['expert'])
rule7 = ctrl.Rule(previous['good'] & current_level['beginner'], next_level['intermediate'])
 
rule1.view()

"""
.. image:: PLOT2RST.current_figure

Control System Creation and Simulation
---------------------------------------

Now that we have our rules defined, we can simply create a control system
via:
"""

outputlevel_ctrl = ctrl.ControlSystem([rule1, rule2, rule3, rule4, rule5, rule6, rule7])

"""
In order to simulate this control system, we will create a
``ControlSystemSimulation``.  Think of this object representing our controller
applied to a specific set of cirucmstances.  For tipping, this might be tipping
Sharon at the local brew-pub.  We would create another
``ControlSystemSimulation`` when we're trying to apply our ``tipping_ctrl``
for Travis at the cafe because the inputs would be different.
"""

outputlevel = ctrl.ControlSystemSimulation(outputlevel_ctrl)

"""
We can now simulate our control system by simply specifying the inputs
and calling the ``compute`` method.  Suppose we rated the quality 6.5 out of 10
and the service 9.8 of 10.
"""
# Pass inputs to the ControlSystem using Antecedent labels with Pythonic API
# Note: if you like passing many inputs all at once, use .inputs(dict_of_data)
outputlevel.input['previous'] = int(sys.argv[1])
outputlevel.input['current_level'] = int(sys.argv[2])

# Crunch the numbers
outputlevel.compute()

"""
Once computed, we can view the result as well as visualize it.
"""
var1 =  outputlevel.output['next_level']

if var1>1:
  var1 = 2 
elif  var1<1:
  var1 = 0
else:
  var1 = 1

print(var1)
sys.stdout.flush()
# next_level.view(sim=outputlevel)

"""
.. image:: PLOT2RST.current_figure

The resulting suggested tip is **20.24%**.

Final thoughts
--------------

The power of fuzzy systems is allowing complicated, intuitive behavior based
on a sparse system of rules with minimal overhead. Note our membership
function universes were coarse, only defined at the integers, but
``fuzz.interp_membership`` allowed the effective resolution to increase on
demand. This system can respond to arbitrarily small changes in inputs,
and the processing burden is minimal.

"""
